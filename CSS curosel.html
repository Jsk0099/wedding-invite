<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2D to 3D Depth Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #threeDiv { width: 100vw; height: 100vh; }
    #imgInput {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <input type="file" id="imgInput" accept="image/*" />
  <div id="threeDiv"></div>

  <!-- âœ… Use module to allow ESM imports from CDN -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import * as ort from 'https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js';

    async function estimateDepth(imgElement, size = 256) {
      const modelURL = 'https://cdn.glitch.me/0f5359e2-6022-421b-88f7-13e276d0fb33/depthanythingv2-vits-dynamic-quant.onnx';
      const session = await ort.InferenceSession.create(modelURL);

      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(imgElement, 0, 0, size, size);
      const imageData = ctx.getImageData(0, 0, size, size).data;

      const rgbData = new Float32Array(size * size * 3);
      for (let i = 0, j = 0; i < imageData.length; i += 4, j += 3) {
        rgbData[j] = imageData[i] / 255;
        rgbData[j + 1] = imageData[i + 1] / 255;
        rgbData[j + 2] = imageData[i + 2] / 255;
      }

      const inputTensor = new ort.Tensor('float32', rgbData, [1, 3, size, size]);
      const feeds = {};
      feeds[session.inputNames[0]] = inputTensor;
      const results = await session.run(feeds);

      const output = results[session.outputNames[0]].data;
      return { depthMap: output, width: size, height: size };
    }

    function create3DScene(image, depth, w, h) {
      const container = document.getElementById('threeDiv');
      container.innerHTML = '';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 10);
      camera.position.set(0, 0, 1.5);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      const min = Math.min(...depth);
      const max = Math.max(...depth);
      const range = max - min;

      const geometry = new THREE.PlaneGeometry(1, 1, w - 1, h - 1);
      const pos = geometry.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const norm = (depth[i] - min) / range;
        pos.setZ(i, -norm * 0.4);
      }
      pos.needsUpdate = true;
      geometry.computeVertexNormals();

      const tex = new THREE.Texture(image);
      tex.needsUpdate = true;
      const material = new THREE.MeshStandardMaterial({
        map: tex,
        flatShading: false,
        side: THREE.DoubleSide,
      });

      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(1, 1, 2);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040));

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    document.getElementById('imgInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const img = new Image();
      img.onload = async () => {
        const { depthMap, width, height } = await estimateDepth(img);
        create3DScene(img, depthMap, width, height);
      };
      img.src = URL.createObjectURL(file);
    });
  </script>
</body>
</html>
